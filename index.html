<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XIAO Remote Control</title>
    <style>
        body { font-family: system-ui, sans-serif; background: #121212; color: white; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; overflow: hidden; }
        #trackpad-card { width: 90vw; height: 60vh; border: 2px dashed #444; border-radius: 20px; display: flex; align-items: center; justify-content: center; cursor: crosshair; transition: border-color 0.3s; }
        #trackpad-card:hover { border-color: #007bff; }
        #status { margin-top: 20px; font-weight: bold; color: #888; }
        .hint { margin-top: 10px; font-size: 0.8rem; color: #555; }
    </style>
</head>
<body>

    <div id="trackpad-card">
        <p>Click to Lock Mouse & Type</p>
    </div>

    <div id="status">Ready to Connect</div>
    <div class="hint">Double-tap 'V' while holding Ctrl to Burst Paste. ESC to unlock.</div>

    <script>
        // --- CONFIG & STATE ---
        let mouseSensitivity = parseFloat(localStorage.getItem("mouseSensitivity")) || 2.0;
        let scrollDecay = parseFloat(localStorage.getItem("scrollDecay")) || 0.95;
        let scrollBoost = parseFloat(localStorage.getItem("scrollBoost")) || 1.4;

        let lastMoveTime = performance.now();
        let smoothX = 0, smoothY = 0;
        let scrollRemainder = 0, lastScrollTime = 0;
        let lastVTime = 0;
        const BURST_DELAY = 100; // Increased slightly for BLE stability

        const TRACKPAD = { smoothing: 0.65, deadzone: 0.15, curveMid: 0.08, curveSharpness: 10 };
        const SCROLL = { scale: 0.02, minStep: 0.05, maxSteps: 6 };

        // --- BLE PLACEHOLDERS (Replace with your actual send/encryption logic) ---
        // Ensure keyChar and sendEncrypted are defined in your broader script context
        const keyChar = null; 
        const mouseChar = null;
        function sendEncrypted(char, data) {
            if (!char) return;
            // Your existing encryption and BLE write logic here
            console.log("Sending:", data); 
        }

        // --- BURST PASTE FIX ---
        async function burstClipboard() {
            try {
                const rawText = await navigator.clipboard.readText();
                if (!rawText) return;

                const text = rawText.replace(/\r\n|\r/g, '\n');
                const statusEl = document.getElementById("status");
                const originalStatus = statusEl.innerText;

                for (let i = 0; i < text.length; i++) {
                    let char = text[i];
                    let charCode = char.charCodeAt(0);
                    
                    statusEl.innerText = `ðŸš€ Sending: ${i + 1}/${text.length}`;

                    if (charCode === 10) {
                        // FIX: Send ASCII 13 (Enter) + Mode 1 (Special) + Mod 1 (Shift)
                        // This matches your Arduino: switch(13) -> KEY_RETURN
                        sendEncrypted(keyChar, new Uint8Array([107, 13, 1, 1]));
                        await new Promise(r => setTimeout(r, 40));
                        
                        // Release all to clear the Shift modifier
                        sendEncrypted(keyChar, new Uint8Array([107, 0, 0, 0]));
                    } else {
                        // Normal Typing (ASCII, Mode 0, No Mod)
                        sendEncrypted(keyChar, new Uint8Array([107, charCode, 0, 0]));
                    }
                    
                    await new Promise(r => setTimeout(r, BURST_DELAY));
                }

                statusEl.innerText = "Paste Complete!";
                setTimeout(() => { statusEl.innerText = originalStatus; }, 2000);
            } catch (err) {
                console.error("Clipboard error:", err);
                document.getElementById("status").innerText = "Clipboard Error";
            }
        }

        // --- CURVES ---
        const accelCurve = (speed) => 1 + 1 / (1 + Math.exp(-TRACKPAD.curveSharpness * (speed - TRACKPAD.curveMid)));
        const scrollCurve = (delta) => Math.abs(delta) < 10 ? Math.abs(delta) * scrollBoost : Math.abs(delta);

        // --- POINTER LOCK ---
        const card = document.getElementById("trackpad-card");
        card.addEventListener("click", () => card.requestPointerLock());

        // --- MOUSE MOVEMENT ---
        document.addEventListener("mousemove", (e) => {
            if (document.pointerLockElement !== card) return;
            const now = performance.now();
            const dt = Math.max(now - lastMoveTime, 1);
            lastMoveTime = now;

            const speed = Math.sqrt(e.movementX**2 + e.movementY**2) / dt;
            smoothX = smoothX * TRACKPAD.smoothing + e.movementX * (1 - TRACKPAD.smoothing);
            smoothY = smoothY * TRACKPAD.smoothing + e.movementY * (1 - TRACKPAD.smoothing);

            if (Math.abs(smoothX) < TRACKPAD.deadzone) smoothX = 0;
            if (Math.abs(smoothY) < TRACKPAD.deadzone) smoothY = 0;

            const accel = accelCurve(speed);
            let outX = Math.max(-127, Math.min(127, Math.round(smoothX * accel * mouseSensitivity)));
            let outY = Math.max(-127, Math.min(127, Math.round(smoothY * accel * mouseSensitivity)));

            if (outX || outY) sendEncrypted(mouseChar, new Int8Array([109, outX, outY]));
        });

        // --- CLICKS ---
        document.addEventListener("mousedown", (e) => {
            if (document.pointerLockElement === card)
                sendEncrypted(mouseChar, new Uint8Array([99, [1, 4, 2][e.button], 1]));
        });
        document.addEventListener("mouseup", (e) => {
            if (document.pointerLockElement === card)
                sendEncrypted(mouseChar, new Uint8Array([99, [1, 4, 2][e.button], 0]));
        });

        // --- SCROLL ---
        document.addEventListener("wheel", (e) => {
            if (document.pointerLockElement !== card) return;
            e.preventDefault();
            lastScrollTime = performance.now();
            let delta = e.deltaY * (e.deltaMode === 1 ? 16 : e.deltaMode === 2 ? 100 : 1);
            scrollRemainder += scrollCurve(delta) * SCROLL.scale;
            let steps = Math.min(Math.floor(Math.abs(scrollRemainder)), SCROLL.maxSteps);
            if (steps === 0) return;
            const dir = delta > 0 ? -1 : 1;
            scrollRemainder -= steps * Math.sign(scrollRemainder);
            for (let i = 0; i < steps; i++) sendEncrypted(mouseChar, new Int8Array([115, dir]));
        }, { passive: false });

        // --- KEYBOARD & BURST TRIGGER ---
        document.addEventListener("keydown", (e) => {
            if (document.pointerLockElement !== card) return;

            // Trigger Burst Paste on Double-V (while Ctrl is held)
            if (e.ctrlKey && e.key.toLowerCase() === 'v') {
                const now = performance.now();
                if (now - lastVTime < 500) {
                    e.preventDefault();
                    lastVTime = 0;
                    burstClipboard();
                    return;
                }
                lastVTime = now;
            }

            let mod = (e.shiftKey ? 1 : 0) | (e.ctrlKey ? 2 : 0) | (e.altKey ? 4 : 0) | (e.metaKey ? 8 : 0);

            e.preventDefault();
            const nav = { Backspace: 8, Tab: 9, Enter: 13, ArrowLeft: 37, ArrowUp: 38, ArrowRight: 39, ArrowDown: 40, Delete: 46 };
            
            if (nav[e.key]) {
                sendEncrypted(keyChar, new Uint8Array([107, nav[e.key], 1, mod]));
            } else if (e.key.length === 1) {
                sendEncrypted(keyChar, new Uint8Array([107, e.key.charCodeAt(0), 0, mod]));
            }
        });

        function decayScrollRemainder() {
            const now = performance.now();
            if (now - lastScrollTime > 40 && scrollRemainder !== 0) {
                scrollRemainder *= Math.pow(scrollDecay, (now - lastScrollTime) / 16);
                if (Math.abs(scrollRemainder) < 0.01) scrollRemainder = 0;
            }
            requestAnimationFrame(decayScrollRemainder);
        }
        decayScrollRemainder();
    </script>
</body>
</html>
