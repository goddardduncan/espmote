<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XIAO-mote Full Pro</title>
    <style>
        body { font-family: system-ui, sans-serif; background: #121212; color: white; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; overflow: hidden; }
        #trackpad-card { width: 90vw; height: 60vh; border: 2px dashed #444; border-radius: 20px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: crosshair; transition: all 0.3s; }
        #trackpad-card:hover { border-color: #007bff; background: #1a1a1a; }
        #status { margin-top: 20px; font-weight: bold; color: #00ff00; }
        .hint { margin-top: 10px; font-size: 0.8rem; color: #555; text-align: center; line-height: 1.5; }
    </style>
</head>
<body>

    <div id="trackpad-card">
        <p>Click to Lock Mouse</p>
        <span style="font-size: 0.7rem; color: #666;">Triple-Tap ` for ESC</span>
    </div>

    <div id="status">Connected</div>
    <div class="hint">
        <b>Ctrl + V + V:</b> Burst Paste<br>
        <b>ESC:</b> Unlock Mouse
    </div>

    <script>
        // --- PERSISTENT STATE ---
        let mouseSensitivity = parseFloat(localStorage.getItem("mouseSensitivity")) || 2.0;
        let scrollDecay = parseFloat(localStorage.getItem("scrollDecay")) || 0.95;
        let scrollBoost = parseFloat(localStorage.getItem("scrollBoost")) || 1.4;

        let lastMoveTime = performance.now();
        let smoothX = 0, smoothY = 0;
        let scrollRemainder = 0, lastScrollTime = 0;
        let tickCount = 0, tickTime;
        let lastVTime = 0;

        const BURST_DELAY = 90; 
        const TRACKPAD = { smoothing: 0.65, deadzone: 0.15, curveMid: 0.08, curveSharpness: 10 };
        const SCROLL = { scale: 0.02, minStep: 0.05, maxSteps: 6 };

        // --- BURST PASTE FIX (Restored with Shift+Enter fix) ---
        async function burstClipboard() {
            try {
                const rawText = await navigator.clipboard.readText();
                if (!rawText) return;

                const text = rawText.replace(/\r\n|\r/g, '\n');
                const statusEl = document.getElementById("status");

                for (let i = 0; i < text.length; i++) {
                    let char = text[i];
                    let charCode = char.charCodeAt(0);
                    statusEl.innerText = `ðŸš€ Sending: ${i + 1}/${text.length}`;

                    if (charCode === 10) {
                        // FIX: Use ASCII 13 + Mode 1 + Modifier 1 (Shift)
                        sendEncrypted(keyChar, new Uint8Array([107, 13, 1, 1]));
                        await new Promise(r => setTimeout(r, 40));
                        // Clean release
                        sendEncrypted(keyChar, new Uint8Array([107, 0, 0, 0]));
                    } else {
                        // Normal char (Mode 0)
                        sendEncrypted(keyChar, new Uint8Array([107, charCode, 0, 0]));
                    }
                    await new Promise(r => setTimeout(r, BURST_DELAY));
                }
                statusEl.innerText = "Paste Complete!";
                setTimeout(() => { statusEl.innerText = "Connected"; }, 2000);
            } catch (err) {
                statusEl.innerText = "Clipboard Error";
            }
        }

        // --- MOUSE LOGIC ---
        const accelCurve = (speed) => 1 + 1 / (1 + Math.exp(-TRACKPAD.curveSharpness * (speed - TRACKPAD.curveMid)));
        
        document.addEventListener("mousemove", (e) => {
            const card = document.getElementById("trackpad-card");
            if (document.pointerLockElement !== card) return;
            const now = performance.now();
            const dt = Math.max(now - lastMoveTime, 1);
            lastMoveTime = now;
            const speed = Math.sqrt(e.movementX**2 + e.movementY**2) / dt;
            smoothX = smoothX * TRACKPAD.smoothing + e.movementX * (1 - TRACKPAD.smoothing);
            smoothY = smoothY * TRACKPAD.smoothing + e.movementY * (1 - TRACKPAD.smoothing);
            if (Math.abs(smoothX) < TRACKPAD.deadzone) smoothX = 0;
            if (Math.abs(smoothY) < TRACKPAD.deadzone) smoothY = 0;
            const accel = accelCurve(speed);
            let outX = Math.max(-127, Math.min(127, Math.round(smoothX * accel * mouseSensitivity)));
            let outY = Math.max(-127, Math.min(127, Math.round(smoothY * accel * mouseSensitivity)));
            if (outX || outY) sendEncrypted(mouseChar, new Int8Array([109, outX, outY]));
        });

        document.addEventListener("mousedown", (e) => {
            if (document.pointerLockElement === document.getElementById("trackpad-card"))
                sendEncrypted(mouseChar, new Uint8Array([99, [1, 4, 2][e.button], 1]));
        });
        document.addEventListener("mouseup", (e) => {
            if (document.pointerLockElement === document.getElementById("trackpad-card"))
                sendEncrypted(mouseChar, new Uint8Array([99, [1, 4, 2][e.button], 0]));
        });

        // --- SCROLLING ---
        document.addEventListener("wheel", (e) => {
            if (document.pointerLockElement !== document.getElementById("trackpad-card")) return;
            e.preventDefault();
            lastScrollTime = performance.now();
            let delta = e.deltaY * (e.deltaMode === 1 ? 16 : e.deltaMode === 2 ? 100 : 1);
            let scrollCurveVal = Math.abs(delta) < 10 ? Math.abs(delta) * scrollBoost : Math.abs(delta);
            scrollRemainder += scrollCurveVal * SCROLL.scale;
            let steps = Math.min(Math.floor(Math.abs(scrollRemainder)), SCROLL.maxSteps);
            if (steps === 0) return;
            const dir = delta > 0 ? -1 : 1;
            scrollRemainder -= steps * Math.sign(scrollRemainder);
            for (let i = 0; i < steps; i++) sendEncrypted(mouseChar, new Int8Array([115, dir]));
        }, { passive: false });

        // --- KEYBOARD (RESTORED MODE 3/4 & TRIPLE-BACKTICK) ---
        document.addEventListener("keydown", (e) => {
            const card = document.getElementById("trackpad-card");
            if (document.pointerLockElement !== card) return;

            // Burst Paste Trigger
            if (e.ctrlKey && e.key.toLowerCase() === 'v') {
                const now = performance.now();
                if (now - lastVTime < 500) {
                    e.preventDefault();
                    lastVTime = 0;
                    burstClipboard();
                    return;
                }
                lastVTime = now;
            }

            let mod = (e.shiftKey ? 1 : 0) | (e.ctrlKey ? 2 : 0) | (e.altKey ? 4 : 0) | (e.metaKey ? 8 : 0);

            // Triple-Backtick logic
            if (e.key === "`") {
                e.preventDefault();
                tickCount++;
                clearTimeout(tickTime);
                if (tickCount === 3) {
                    sendEncrypted(keyChar, new Uint8Array([107, 27, 1, 0])); // ESC
                    tickCount = 0;
                } else {
                    tickTime = setTimeout(() => {
                        if (tickCount === 1) sendEncrypted(keyChar, new Uint8Array([107, 96, 0, mod]));
                        tickCount = 0;
                    }, 500);
                }
                return;
            }

            e.preventDefault();

            // Handle Mode 3/4 System Shortcuts (Ctrl/Meta + Key)
            if (e.ctrlKey && e.key === "Tab") {
                sendEncrypted(keyChar, new Uint8Array([107, 128, 4, 9]));
            } else if ((e.ctrlKey || e.metaKey) && e.key.length === 1) {
                // Arduino expects Mode 3 for Ctrl, Mode 4 for Meta
                sendEncrypted(keyChar, new Uint8Array([107, 128, e.metaKey ? 4 : 3, e.key.toLowerCase().charCodeAt(0)]));
            } else {
                // Nav/Special Keys (Mode 1)
                const nav = { Backspace: 8, Tab: 9, Enter: 13, Escape: 27, ArrowLeft: 37, ArrowUp: 38, ArrowRight: 39, ArrowDown: 40, Delete: 46 };
                if (nav[e.key]) {
                    sendEncrypted(keyChar, new Uint8Array([107, nav[e.key], 1, mod]));
                } else if (e.key.length === 1) {
                    // Normal text
                    sendEncrypted(keyChar, new Uint8Array([107, e.key.charCodeAt(0), 0, mod]));
                }
            }
        });

        // Pointer Lock Trigger
        card.addEventListener("click", () => card.requestPointerLock());

        function decayScrollRemainder() {
            const now = performance.now();
            if (now - lastScrollTime > 40 && scrollRemainder !== 0) {
                scrollRemainder *= Math.pow(scrollDecay, (now - lastScrollTime) / 16);
                if (Math.abs(scrollRemainder) < 0.01) scrollRemainder = 0;
            }
            requestAnimationFrame(decayScrollRemainder);
        }
        decayScrollRemainder();
    </script>
</body>
</html>
